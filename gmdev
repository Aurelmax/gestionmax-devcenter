#!/bin/bash
# GestionMax Dev Runtime (gmdev)
# Runtime officiel pour g√©rer les services de d√©veloppement
# Logs + PID files + project detection robustness
# Version: 2.0.0

set -euo pipefail

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
PROJECTS_CONFIG="${GMDEV_PROJECTS_CONFIG:-$HOME/.gestionmax-devcenter/projects-v3.json}"
PROJECT_ROOT="${GMDEV_PROJECT_ROOT:-$(pwd)}"

# Logs
GMDEV_STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/gmdev"
GMDEV_LOG_DIR="$GMDEV_STATE_DIR/logs"
GMDEV_PID_DIR="$GMDEV_STATE_DIR/pids"

mkdir -p "$GMDEV_LOG_DIR" "$GMDEV_PID_DIR"

ts() { date "+%Y-%m-%d %H:%M:%S"; }

# Fonctions utilitaires
error() {
    echo -e "${RED}‚ùå Erreur:${NC} $1" >&2
    exit 1
}

info() {
    echo -e "${BLUE}‚ÑπÔ∏è${NC} $1"
}

success() {
    echo -e "${GREEN}‚úÖ${NC} $1"
}

warning() {
    echo -e "${YELLOW}‚ö†Ô∏è${NC} $1"
}

# Normalise un chemin (best-effort)
normpath() {
    local p="$1"
    if command -v realpath >/dev/null 2>&1; then
        realpath -m "$p"
    else
        (cd "$p" 2>/dev/null && pwd) || echo "$p"
    fi
}

# D√©tecte le projet courant depuis le r√©pertoire de travail
detect_project() {
    local current_dir
    current_dir="$(normpath "$PROJECT_ROOT")"
    
    # Chercher dans projects-v3.json
    if [ -f "$PROJECTS_CONFIG" ]; then
        # Extraire le projet qui correspond au r√©pertoire courant
        local project_id
        project_id=$(jq -r --arg dir "$current_dir" '
            .projects[] |
            select(
              (.rootPath     // "" | startswith($dir)) or
              (.backendPath  // "" | startswith($dir)) or
              (.frontendPath // "" | startswith($dir)) or
              ($dir | startswith(.rootPath // "")) or
              ($dir | startswith(.backendPath // "")) or
              ($dir | startswith(.frontendPath // ""))
            ) |
            .id
        ' "$PROJECTS_CONFIG" 2>/dev/null | head -1)
        
        if [ -n "$project_id" ] && [ "$project_id" != "null" ]; then
            echo "$project_id"
            return 0
        fi
    fi
    
    # Fallback: utiliser le nom du r√©pertoire
    basename "$current_dir" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g'
}

pidfile() {
    local project_id="$1"
    local service="$2"
    echo "$GMDEV_PID_DIR/${project_id}.${service}.pid"
}

# Charge la configuration du projet
load_project_config() {
    local project_id="$1"
    
    if [ ! -f "$PROJECTS_CONFIG" ]; then
        error "Fichier de configuration introuvable: $PROJECTS_CONFIG"
    fi
    
    jq -r --arg id "$project_id" '.projects[] | select(.id == $id)' "$PROJECTS_CONFIG" 2>/dev/null
}

# Trouve le PID d'un service
find_service_pid() {
    local service="$1"
    local port="$2"
    
    # Pour le backend, chercher d'abord par nom de processus (car il peut ne pas √©couter sur un port)
    if [[ "$service" == "back" || "$service" == "backend" ]]; then
        local pid=$(pgrep -f "tsx.*watch.*server\|tsx.*server\|node.*payload\|cross-env.*tsx.*server" | head -1)
        if [ -n "$pid" ]; then
            # V√©rifier que ce n'est pas un processus next-server
            if ! ps -p "$pid" 2>/dev/null | grep -q "next-server"; then
                echo "$pid"
                return 0
            fi
        fi
        # Si pas trouv√© par processus, essayer par port
        if [ -n "$port" ] && [ "$port" != "0" ]; then
            pid=$(lsof -ti:"$port" 2>/dev/null | head -1)
            if [ -z "$pid" ]; then
                pid=$(ss -tlnp 2>/dev/null | grep ":$port " | grep -oP 'pid=\K[0-9]+' | head -1)
            fi
            if [ -z "$pid" ]; then
                pid=$(netstat -tlnp 2>/dev/null | grep ":$port " | grep -oP '[0-9]+/[^ ]+' | cut -d'/' -f1 | head -1)
            fi
            # V√©rifier que ce n'est pas next-server
            if [ -n "$pid" ] && ! ps -p "$pid" 2>/dev/null | grep -q "next-server"; then
                echo "$pid"
                return 0
            fi
        fi
        return 1
    fi
    
    # Pour les autres services, chercher par port d'abord
    if [ -n "$port" ] && [ "$port" != "0" ]; then
        # Essayer lsof d'abord
        local pid=$(lsof -ti:"$port" 2>/dev/null | head -1)
        if [ -z "$pid" ]; then
            # Fallback: utiliser ss ou netstat pour IPv6
            pid=$(ss -tlnp 2>/dev/null | grep ":$port " | grep -oP 'pid=\K[0-9]+' | head -1)
        fi
        if [ -z "$pid" ]; then
            # Autre fallback: netstat
            pid=$(netstat -tlnp 2>/dev/null | grep ":$port " | grep -oP '[0-9]+/[^ ]+' | cut -d'/' -f1 | head -1)
        fi
        if [ -n "$pid" ]; then
            echo "$pid"
            return 0
        fi
    fi
    
    # Chercher par nom de processus (fallback)
    case "$service" in
        tunnel)
            pgrep -f "ssh.*-L.*:.*:.*" | head -1
            ;;
        front|frontend)
            # Chercher les processus next.js (next dev, next-server, node next)
            pgrep -f "next.*dev\|next-server\|node.*next" | head -1
            ;;
        mini-gods|minigods)
            # Chercher les processus SSH qui ex√©cutent mini-gods
            pgrep -f "ssh.*mini-gods\|ssh.*minigods" | head -1
            ;;
    esac
}

# D√©marre un service
start_service() {
    local service="$1"
    local project_id="${2:-}"
    
    if [ -z "$project_id" ]; then
        project_id=$(detect_project)
    fi
    
    local config=$(load_project_config "$project_id")
    if [ -z "$config" ]; then
        error "Projet '$project_id' introuvable dans la configuration"
    fi
    
    case "$service" in
        tunnel)
            start_tunnel "$config"
            ;;
        back|backend)
            start_backend "$config"
            ;;
        front|frontend)
            start_frontend "$config"
            ;;
        mini-gods|minigods)
            start_ssh_service "$config" "mini-gods"
            ;;
        *)
            error "Service inconnu: $service. Services valides: tunnel, back, front, mini-gods"
            ;;
    esac
}

# D√©marre le tunnel SSH
start_tunnel() {
    local config="$1"
    
    local host=$(echo "$config" | jq -r '.tunnel.host // empty')
    local user=$(echo "$config" | jq -r '.tunnel.user // "root"')
    local port=$(echo "$config" | jq -r '.tunnel.port // 22')
    local key=$(echo "$config" | jq -r '.tunnel.privateKey // empty')
    local local_mongo=$(echo "$config" | jq -r '.tunnel.localMongo // 27017')
    local remote_mongo=$(echo "$config" | jq -r '.tunnel.remoteMongo // 27017')
    local mongo_host=$(echo "$config" | jq -r '.tunnel.mongoHost // "127.0.0.1"')
    
    if [ -z "$host" ] || [ "$host" == "null" ]; then
        error "Tunnel non configur√© pour ce projet"
    fi
    
    # V√©rifier si d√©j√† en cours d'ex√©cution
    local existing_pid=$(find_service_pid "tunnel" "$local_mongo")
    if [ -n "$existing_pid" ]; then
        warning "Tunnel d√©j√† en cours d'ex√©cution (PID: $existing_pid)"
        return 0
    fi
    
    if [ -z "$key" ] || [ "$key" == "null" ]; then
        key="$HOME/.ssh/id_ed25519_hetzner"
    fi
    
    if [ ! -f "$key" ]; then
        error "Cl√© SSH introuvable: $key"
    fi
    
    info "üîê D√©marrage tunnel SSH: localhost:$local_mongo ‚Üí $mongo_host:$remote_mongo (via $host)"
    
    ssh -i "$key" \
        -p "$port" \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o ServerAliveInterval=60 \
        -o ServerAliveCountMax=3 \
        -N \
        -L "${local_mongo}:${mongo_host}:${remote_mongo}" \
        "${user}@${host}" >/dev/null 2>&1 &
    
    local pid=$!
    sleep 1
    
    if ps -p "$pid" >/dev/null 2>&1; then
        success "Tunnel SSH actif (PID: $pid)"
    else
        error "√âchec du d√©marrage du tunnel SSH"
    fi
}

# D√©marre un service SSH (ex√©cute une commande sur le serveur distant)
start_ssh_service() {
    local config="$1"
    local service_name="$2"
    
    local host=$(echo "$config" | jq -r '.tunnel.host // empty')
    local user=$(echo "$config" | jq -r '.tunnel.user // "root"')
    local port=$(echo "$config" | jq -r '.tunnel.port // 22')
    local key=$(echo "$config" | jq -r '.tunnel.privateKey // empty')
    
    # R√©cup√©rer la commande SSH depuis la configuration du service
    local ssh_command=$(echo "$config" | jq -r ".commands.${service_name} // empty")
    local service_port=$(echo "$config" | jq -r ".ports.${service_name} // empty")
    local project_id=$(echo "$config" | jq -r '.id // "unknown"')
    local log_file="$GMDEV_LOG_DIR/${project_id}.${service_name}.log"
    local pf; pf="$(pidfile "$project_id" "$service_name")"
    
    if [ -z "$host" ] || [ "$host" == "null" ]; then
        error "Tunnel non configur√© pour ce projet"
    fi
    
    if [ -z "$ssh_command" ] || [ "$ssh_command" == "null" ]; then
        error "Commande SSH non configur√©e pour le service '$service_name'. Ajoutez 'commands.${service_name}' dans la configuration."
    fi
    
    if [ -z "$key" ] || [ "$key" == "null" ]; then
        key="$HOME/.ssh/id_ed25519"
    fi
    
    if [ ! -f "$key" ]; then
        error "Cl√© SSH introuvable: $key"
    fi
    
    # V√©rifier si d√©j√† en cours d'ex√©cution
    local existing_pid=""
    if [ -n "$service_port" ] && [ "$service_port" != "null" ] && [ "$service_port" != "0" ]; then
        existing_pid=$(find_service_pid "$service_name" "$service_port")
    else
        # V√©rifier par PID file
        if [ -f "$pf" ]; then
            local saved_pid=$(cat "$pf" 2>/dev/null)
            if [ -n "$saved_pid" ] && ps -p "$saved_pid" >/dev/null 2>&1; then
                existing_pid="$saved_pid"
            fi
        fi
    fi
    
    if [ -n "$existing_pid" ]; then
        warning "Service '$service_name' d√©j√† en cours d'ex√©cution (PID: $existing_pid)"
        return 0
    fi
    
    info "üìù Logs ${service_name} ‚Üí $log_file"
    echo "[$(ts)] gmdev start ${service_name} (cmd=$ssh_command, host=$host)" >> "$log_file"
    
    info "üöÄ D√©marrage ${service_name} via SSH sur $host..."
    
    # Ex√©cuter la commande SSH en arri√®re-plan
    ssh -i "$key" \
        -p "$port" \
        -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o ServerAliveInterval=60 \
        -o ServerAliveCountMax=3 \
        "${user}@${host}" \
        "$ssh_command" >>"$log_file" 2>&1 &
    
    local pid=$!
    echo "$pid" > "$pf"
    sleep 2
    
    # V√©rifier si le processus tourne
    if ps -p "$pid" >/dev/null 2>&1; then
        success "${service_name} d√©marr√© via SSH (PID: $pid)"
    else
        # V√©rifier si le port est utilis√© (si configur√©)
        if [ -n "$service_port" ] && [ "$service_port" != "null" ] && [ "$service_port" != "0" ]; then
            local actual_pid=$(find_service_pid "$service_name" "$service_port")
            if [ -n "$actual_pid" ]; then
                echo "$actual_pid" > "$pf"
                success "${service_name} d√©marr√© via SSH (PID: $actual_pid)"
            else
                error "√âchec du d√©marrage de ${service_name}. V√©rifiez les logs: $log_file"
            fi
        else
            error "√âchec du d√©marrage de ${service_name}. V√©rifiez les logs: $log_file"
        fi
    fi
}

# D√©marre le backend
start_backend() {
    local config="$1"
    
    local backend_path=$(echo "$config" | jq -r '.backendPath // empty')
    local backend_port=$(echo "$config" | jq -r '.ports.backend // 3000')
    local command=$(echo "$config" | jq -r '.commands.backend // "npm run dev"')
    local project_id=$(echo "$config" | jq -r '.id // "unknown"')
    local log_file="$GMDEV_LOG_DIR/${project_id}.backend.log"
    local pf; pf="$(pidfile "$project_id" "backend")"
    
    if [ -z "$backend_path" ] || [ "$backend_path" == "null" ]; then
        error "Backend non configur√© pour ce projet"
    fi
    
    if [ ! -d "$backend_path" ]; then
        error "R√©pertoire backend introuvable: $backend_path"
    fi
    
    # V√©rifier si d√©j√† en cours d'ex√©cution
    local existing_pid=$(find_service_pid "back" "$backend_port")
    if [ -n "$existing_pid" ]; then
        warning "Backend d√©j√† en cours d'ex√©cution (PID: $existing_pid)"
        return 0
    fi
    
    info "üìù Logs backend ‚Üí $log_file"
    echo "[$(ts)] gmdev start backend (cmd=$command, port=$backend_port, path=$backend_path)" >> "$log_file"
    
    # Installer les d√©pendances si n√©cessaire
    if [ ! -d "$backend_path/node_modules" ]; then
        info "üì¶ Installation des d√©pendances..."
        
        # D√©tecter le gestionnaire de paquets
        local install_cmd="npm install"
        if [ -f "$backend_path/pnpm-lock.yaml" ] && command -v pnpm &> /dev/null; then
            install_cmd="pnpm install"
        elif [ -f "$backend_path/yarn.lock" ] && command -v yarn &> /dev/null; then
            install_cmd="yarn install"
        fi
        
        info "Installation avec: $install_cmd"
        # Forcer l'installation locale pour pnpm
        if [[ "$install_cmd" == *"pnpm"* ]]; then
            # pnpm avec shamefully-hoist peut installer dans ~/node_modules
            # V√©rifier d'abord si node_modules existe localement ou globalement
            if [ ! -d "$backend_path/node_modules" ] && [ -d "$HOME/node_modules" ]; then
                # Cr√©er un lien symbolique si node_modules est global
                warning "node_modules trouv√© globalement, cr√©ation d'un lien symbolique..."
                ln -sf "$HOME/node_modules" "$backend_path/node_modules" 2>/dev/null || true
            fi
            
            # Installer m√™me si node_modules existe (pour mettre √† jour)
            (cd "$backend_path" && echo "y" | pnpm install 2>&1 | grep -v "will be removed" | tail -10)
            
            # V√©rifier que node_modules existe maintenant (local ou global)
            if [ ! -d "$backend_path/node_modules" ] && [ ! -d "$HOME/node_modules" ]; then
                error "√âchec de l'installation des d√©pendances (node_modules introuvable)"
            fi
        else
            (cd "$backend_path" && $install_cmd) || error "√âchec de l'installation des d√©pendances"
        fi
    fi
    
    info "üöÄ D√©marrage backend sur le port $backend_port..."
    
    # Pr√©parer le PATH pour inclure node_modules/.bin
    local node_bin=""
    if [ -d "$backend_path/node_modules/.bin" ]; then
        node_bin="$backend_path/node_modules/.bin:"
    elif [ -d "$HOME/node_modules/.bin" ]; then
        node_bin="$HOME/node_modules/.bin:"
    fi
    
    # D√©marrer le backend avec le bon PATH
    (cd "$backend_path" && PATH="${node_bin}$PATH" $command >>"$log_file" 2>&1) &
    local pid=$!
    echo "$pid" > "$pf"
    sleep 3
    
    # V√©rifier si le processus tourne ou si le port est utilis√©
    if ps -p "$pid" >/dev/null 2>&1 || find_service_pid "back" "$backend_port" >/dev/null; then
        local actual_pid=$(find_service_pid "back" "$backend_port" || echo "$pid")
        success "Backend d√©marr√© (PID: $actual_pid)"
    else
        error "√âchec du d√©marrage du backend. V√©rifiez les logs."
    fi
}

# D√©marre le frontend
start_frontend() {
    local config="$1"
    
    local frontend_path=$(echo "$config" | jq -r '.frontendPath // empty')
    local frontend_port=$(echo "$config" | jq -r '.ports.frontend // 3000')
    local command=$(echo "$config" | jq -r '.commands.frontend // "npm run dev"')
    local project_id=$(echo "$config" | jq -r '.id // "unknown"')
    local log_file="$GMDEV_LOG_DIR/${project_id}.frontend.log"
    local pf; pf="$(pidfile "$project_id" "frontend")"
    
    if [ -z "$frontend_path" ] || [ "$frontend_path" == "null" ]; then
        error "Frontend non configur√© pour ce projet"
    fi
    
    if [ ! -d "$frontend_path" ]; then
        error "R√©pertoire frontend introuvable: $frontend_path"
    fi
    
    # V√©rifier si d√©j√† en cours d'ex√©cution
    local existing_pid=$(find_service_pid "front" "$frontend_port")
    if [ -n "$existing_pid" ]; then
        warning "Frontend d√©j√† en cours d'ex√©cution (PID: $existing_pid)"
        return 0
    fi
    
    info "üìù Logs frontend ‚Üí $log_file"
    echo "[$(ts)] gmdev start frontend (cmd=$command, port=$frontend_port, path=$frontend_path)" >> "$log_file"
    
    # Installer les d√©pendances si n√©cessaire
    if [ ! -d "$frontend_path/node_modules" ]; then
        info "üì¶ Installation des d√©pendances..."
        
        # D√©tecter le gestionnaire de paquets
        local install_cmd="npm install"
        if [ -f "$frontend_path/pnpm-lock.yaml" ] && command -v pnpm &> /dev/null; then
            install_cmd="pnpm install"
        elif [ -f "$frontend_path/yarn.lock" ] && command -v yarn &> /dev/null; then
            install_cmd="yarn install"
        fi
        
        info "Installation avec: $install_cmd"
        # Forcer l'installation locale pour pnpm
        if [[ "$install_cmd" == *"pnpm"* ]]; then
            # Utiliser PNPM_HOME et forcer l'installation locale
            (cd "$frontend_path" && PNPM_HOME="" pnpm install --shamefully-hoist=false 2>&1 | grep -v "will be removed" | grep -v "Proceed?" || true)
            # Attendre un peu pour que l'installation se termine
            sleep 2
            # V√©rifier que node_modules existe maintenant
            if [ ! -d "$frontend_path/node_modules" ]; then
                warning "node_modules introuvable apr√®s installation, r√©essayant..."
                (cd "$frontend_path" && pnpm install --force 2>&1 | tail -5)
                if [ ! -d "$frontend_path/node_modules" ]; then
                    error "√âchec de l'installation des d√©pendances (node_modules introuvable)"
                fi
            fi
        else
            (cd "$frontend_path" && $install_cmd) || error "√âchec de l'installation des d√©pendances"
        fi
    fi
    
    info "üöÄ D√©marrage frontend sur le port $frontend_port..."
    
    # Pr√©parer le PATH pour inclure node_modules/.bin
    local node_bin=""
    if [ -d "$frontend_path/node_modules/.bin" ]; then
        node_bin="$frontend_path/node_modules/.bin:"
    elif [ -d "$HOME/node_modules/.bin" ]; then
        node_bin="$HOME/node_modules/.bin:"
    fi
    
    # D√©marrer le frontend avec le bon PATH
    (cd "$frontend_path" && PATH="${node_bin}$PATH" $command >>"$log_file" 2>&1) &
    local pid=$!
    echo "$pid" > "$pf"
    sleep 3
    
    # V√©rifier si le processus tourne ou si le port est utilis√©
    if ps -p "$pid" >/dev/null 2>&1 || find_service_pid "front" "$frontend_port" >/dev/null; then
        local actual_pid=$(find_service_pid "front" "$frontend_port" || echo "$pid")
        success "Frontend d√©marr√© (PID: $actual_pid)"
    else
        error "√âchec du d√©marrage du frontend. V√©rifiez les logs."
    fi
}

# Arr√™te un service
stop_service() {
    local service="$1"
    local project_id="${2:-}"
    
    if [ -z "$project_id" ]; then
        project_id=$(detect_project)
    fi
    
    local config=$(load_project_config "$project_id")
    if [ -z "$config" ]; then
        error "Projet '$project_id' introuvable dans la configuration"
    fi
    
    case "$service" in
        tunnel)
            stop_tunnel "$config"
            ;;
        back|backend)
            stop_backend "$config"
            ;;
        front|frontend)
            stop_frontend "$config"
            ;;
        mini-gods|minigods)
            stop_ssh_service "$config" "mini-gods"
            ;;
        *)
            error "Service inconnu: $service. Services valides: tunnel, back, front, mini-gods"
            ;;
    esac
}

# Arr√™te le tunnel
stop_tunnel() {
    local config="$1"
    local local_mongo=$(echo "$config" | jq -r '.tunnel.localMongo // 27017')
    
    local pid=$(find_service_pid "tunnel" "$local_mongo")
    if [ -z "$pid" ]; then
        warning "Tunnel non en cours d'ex√©cution"
        return 0
    fi
    
    info "Arr√™t du tunnel (PID: $pid)..."
    kill "$pid" 2>/dev/null || true
    sleep 1
    
    if ! ps -p "$pid" >/dev/null 2>&1; then
        success "Tunnel arr√™t√©"
    else
        error "√âchec de l'arr√™t du tunnel"
    fi
}

# Arr√™te un service SSH
stop_ssh_service() {
    local config="$1"
    local service_name="$2"
    
    local service_port=$(echo "$config" | jq -r ".ports.${service_name} // empty")
    local project_id=$(echo "$config" | jq -r '.id // "unknown"')
    local pf; pf="$(pidfile "$project_id" "$service_name")"
    
    # Trouver le PID
    local pid=""
    if [ -n "$service_port" ] && [ "$service_port" != "null" ] && [ "$service_port" != "0" ]; then
        pid=$(find_service_pid "$service_name" "$service_port")
    fi
    
    # Si pas trouv√© par port, essayer le PID file
    if [ -z "$pid" ] && [ -f "$pf" ]; then
        local saved_pid=$(cat "$pf" 2>/dev/null)
        if [ -n "$saved_pid" ] && ps -p "$saved_pid" >/dev/null 2>&1; then
            pid="$saved_pid"
        fi
    fi
    
    if [ -z "$pid" ]; then
        warning "Service '$service_name' non en cours d'ex√©cution"
        rm -f "$pf" 2>/dev/null || true
        return 0
    fi
    
    info "Arr√™t du service '$service_name' (PID: $pid)..."
    
    # Tuer le processus SSH
    kill "$pid" 2>/dev/null || true
    sleep 1
    
    # Si c'est un processus SSH, tuer aussi les processus enfants sur le serveur distant
    local host=$(echo "$config" | jq -r '.tunnel.host // empty')
    local user=$(echo "$config" | jq -r '.tunnel.user // "root"')
    local ssh_port=$(echo "$config" | jq -r '.tunnel.port // 22')
    local key=$(echo "$config" | jq -r '.tunnel.privateKey // empty')
    
    if [ -n "$host" ] && [ "$host" != "null" ]; then
        if [ -z "$key" ] || [ "$key" == "null" ]; then
            key="$HOME/.ssh/id_ed25519"
        fi
        
        # R√©cup√©rer la commande pour trouver et tuer le processus sur le serveur distant
        local ssh_command=$(echo "$config" | jq -r ".commands.${service_name} // empty")
        if [ -n "$ssh_command" ] && [ "$ssh_command" != "null" ]; then
            # Extraire le nom du processus depuis la commande (approximation)
            local process_name=$(echo "$ssh_command" | awk '{print $NF}' | xargs basename 2>/dev/null || echo "")
            if [ -n "$process_name" ]; then
                # Tuer les processus correspondants sur le serveur distant
                ssh -i "$key" \
                    -p "$ssh_port" \
                    -o StrictHostKeyChecking=no \
                    -o UserKnownHostsFile=/dev/null \
                    "${user}@${host}" \
                    "pkill -f '$process_name' || true" 2>/dev/null || true
            fi
        fi
    fi
    
    if ! ps -p "$pid" >/dev/null 2>&1; then
        rm -f "$pf" 2>/dev/null || true
        success "Service '$service_name' arr√™t√©"
    else
        error "√âchec de l'arr√™t du service '$service_name'"
    fi
}

# Arr√™te le backend
stop_backend() {
    local config="$1"
    local backend_port=$(echo "$config" | jq -r '.ports.backend // 3000')
    local project_id=$(echo "$config" | jq -r '.id // "unknown"')
    local pf; pf="$(pidfile "$project_id" "backend")"
    
    local pid=""
    if [ -f "$pf" ]; then pid="$(cat "$pf" 2>/dev/null || true)"; fi
    if [ -z "$pid" ]; then pid="$(find_service_pid "back" "$backend_port" || true)"; fi
    if [ -z "$pid" ]; then
        warning "Backend non en cours d'ex√©cution"
        return 0
    fi
    
    info "Arr√™t du backend (PID: $pid)..."
    kill "$pid" 2>/dev/null || true
    sleep 1
    
    if ! ps -p "$pid" >/dev/null 2>&1; then
        success "Backend arr√™t√©"
        rm -f "$pf" 2>/dev/null || true
    else
        warning "Arr√™t forc√© du backend"
        kill -9 "$pid" 2>/dev/null || true
        rm -f "$pf" 2>/dev/null || true
    fi
}

# Arr√™te le frontend
stop_frontend() {
    local config="$1"
    local frontend_port=$(echo "$config" | jq -r '.ports.frontend // 3000')
    local project_id=$(echo "$config" | jq -r '.id // "unknown"')
    local pf; pf="$(pidfile "$project_id" "frontend")"
    
    local pid=""
    if [ -f "$pf" ]; then pid="$(cat "$pf" 2>/dev/null || true)"; fi
    if [ -z "$pid" ]; then pid="$(find_service_pid "front" "$frontend_port" || true)"; fi
    if [ -z "$pid" ]; then
        warning "Frontend non en cours d'ex√©cution"
        return 0
    fi
    
    info "Arr√™t du frontend (PID: $pid)..."
    kill "$pid" 2>/dev/null || true
    sleep 1
    
    if ! ps -p "$pid" >/dev/null 2>&1; then
        success "Frontend arr√™t√©"
        rm -f "$pf" 2>/dev/null || true
    else
        warning "Arr√™t forc√© du frontend"
        kill -9 "$pid" 2>/dev/null || true
        rm -f "$pf" 2>/dev/null || true
    fi
}

# Red√©marre un service
restart_service() {
    local service="$1"
    local project_id="${2:-}"
    
    info "Red√©marrage de $service..."
    stop_service "$service" "$project_id"
    sleep 1
    start_service "$service" "$project_id"
}

# Fonction doctor pour diagnostic
doctor() {
    local project_id="${1:-}"
    if [ -z "$project_id" ]; then
        project_id="$(detect_project)"
    fi

    local config
    config="$(load_project_config "$project_id" 2>/dev/null || true)"
    if [ -z "$config" ] || [ "$config" = "null" ]; then
        error "Projet '$project_id' introuvable dans $PROJECTS_CONFIG"
    fi

    local name backend_path frontend_path backend_port frontend_port tunnel_host local_mongo
    name="$(printf '%s' "$config" | jq -r '.name // "?"')"
    backend_path="$(printf '%s' "$config" | jq -r '.backendPath // ""')"
    frontend_path="$(printf '%s' "$config" | jq -r '.frontendPath // ""')"
    backend_port="$(printf '%s' "$config" | jq -r '.ports.backend // 3010')"
    frontend_port="$(printf '%s' "$config" | jq -r '.ports.frontend // 3000')"
    tunnel_host="$(printf '%s' "$config" | jq -r '.tunnel.host // ""')"
    local_mongo="$(printf '%s' "$config" | jq -r '.tunnel.localMongo // 27017')"

    printf '\n%s\n' "ü©∫ gmdev doctor ‚Äî $name ($project_id)"
    printf '%s\n' "Config: $PROJECTS_CONFIG"
    printf '%s\n' "State : $GMDEV_STATE_DIR"
    printf '\n'

    # D√©pendances
    local ok=1
    for bin in jq lsof; do
        if command -v "$bin" >/dev/null 2>&1; then
            printf '%s\n' "‚úÖ dep: $bin"
        else
            printf '%s\n' "‚ùå dep: $bin (manquant)"
            ok=0
        fi
    done

    # R√©pertoires
    if [ -n "$backend_path" ]; then
        if [ -d "$backend_path" ]; then
            printf '%s\n' "‚úÖ backendPath: $backend_path"
        else
            printf '%s\n' "‚ùå backendPath: $backend_path (introuvable)"
            ok=0
        fi
    else
        printf '%s\n' "‚ÑπÔ∏è backendPath: (absent) ‚Üí projet sans backend"
    fi

    if [ -n "$frontend_path" ]; then
        if [ -d "$frontend_path" ]; then
            printf '%s\n' "‚úÖ frontendPath: $frontend_path"
        else
            printf '%s\n' "‚ùå frontendPath: $frontend_path (introuvable)"
            ok=0
        fi
    else
        printf '%s\n' "‚ÑπÔ∏è frontendPath: (absent)"
    fi

    # Ports
    if lsof -ti:"$frontend_port" >/dev/null 2>&1; then
        printf '%s\n' "‚úÖ port frontend :$frontend_port (occup√© = OK si front tourne)"
    else
        printf '%s\n' "‚ÑπÔ∏è port frontend :$frontend_port (libre)"
    fi

    if [ -n "$backend_path" ]; then
        if lsof -ti:"$backend_port" >/dev/null 2>&1; then
            printf '%s\n' "‚úÖ port backend  :$backend_port (occup√© = OK si back tourne)"
        else
            printf '%s\n' "‚ÑπÔ∏è port backend  :$backend_port (libre)"
        fi
    fi

    # Tunnel
    if [ -n "$backend_path" ] && [ -n "$tunnel_host" ]; then
        if lsof -ti:"$local_mongo" >/dev/null 2>&1; then
            printf '%s\n' "‚úÖ tunnel port mongo :$local_mongo (occup√©)"
        else
            printf '%s\n' "‚ÑπÔ∏è tunnel port mongo :$local_mongo (libre)"
        fi
        # Test reachability (sans bloquer)
        if timeout 3 bash -lc "nc -z \"$tunnel_host\" 22" >/dev/null 2>&1; then
            printf '%s\n' "‚úÖ ssh: $tunnel_host:22 joignable"
        else
            printf '%s\n' "‚ö†Ô∏è ssh: $tunnel_host:22 non joignable (ou nc absent)"
        fi
    else
        printf '%s\n' "‚ÑπÔ∏è tunnel: non applicable (pas de backend ou pas de host)"
    fi

    printf '\n%s\n' "R√©sultat: $( [ "$ok" -eq 1 ] && printf '‚úÖ OK' || printf '‚ö†Ô∏è √Ä corriger' )"
    printf '\n'
}

# Affiche le statut des services
show_status() {
    local project_id="${1:-}"
    local format="${2:-}"  # "--json" ou "--format json"
    
    if [ -z "$project_id" ]; then
        project_id=$(detect_project)
    fi
    
    local config=$(load_project_config "$project_id")
    if [ -z "$config" ]; then
        error "Projet '$project_id' introuvable dans la configuration"
    fi
    
    local tunnel_port=$(echo "$config" | jq -r '.tunnel.localMongo // 27017')
    local backend_port=$(echo "$config" | jq -r '.ports.backend // 3000')
    local frontend_port=$(echo "$config" | jq -r '.ports.frontend // 3000')
    
    # Tunnel
    local tunnel_pid=$(find_service_pid "tunnel" "$tunnel_port")
    local tunnel_state="stopped"
    if [ -n "$tunnel_pid" ]; then
        tunnel_state="running"
    fi
    
    # Backend
    local backend_pid=$(find_service_pid "back" "$backend_port")
    local backend_state="stopped"
    if [ -n "$backend_pid" ]; then
        backend_state="running"
    fi
    
    # Frontend
    local frontend_pid=$(find_service_pid "front" "$frontend_port")
    local frontend_state="stopped"
    if [ -n "$frontend_pid" ]; then
        frontend_state="running"
    fi
    
    # Si format JSON demand√©
    local json_format=false
    if [ "$format" = "--json" ]; then
        json_format=true
    elif [ "$format" = "--format" ] && [ "${3:-}" = "json" ]; then
        json_format=true
    fi
    
    if [ "$json_format" = "true" ]; then
        # Retourner JSON stable
        jq -n \
          --arg tunnel_state "$tunnel_state" \
          --arg backend_state "$backend_state" \
          --arg frontend_state "$frontend_state" \
          --argjson tunnel_port "$tunnel_port" \
          --argjson backend_port "$backend_port" \
          --argjson frontend_port "$frontend_port" \
          --arg tunnel_pid "${tunnel_pid:-}" \
          --arg backend_pid "${backend_pid:-}" \
          --arg frontend_pid "${frontend_pid:-}" \
          '{
            "services": {
              "tunnel": {
                "state": $tunnel_state,
                "port": ($tunnel_port | tonumber),
                "pid": (if $tunnel_pid == "" then null else ($tunnel_pid | tonumber) end)
              },
              "backend": {
                "state": $backend_state,
                "port": ($backend_port | tonumber),
                "pid": (if $backend_pid == "" then null else ($backend_pid | tonumber) end)
              },
              "frontend": {
                "state": $frontend_state,
                "port": ($frontend_port | tonumber),
                "pid": (if $frontend_pid == "" then null else ($frontend_pid | tonumber) end)
              }
            }
          }'
        return 0
    fi
    
    # Format texte (par d√©faut)
    echo -e "${BLUE}üìä Statut des services - $(echo "$config" | jq -r '.name // "Projet inconnu"')${NC}"
    echo ""
    
    if [ "$tunnel_state" = "running" ]; then
        echo -e "  ${GREEN}‚óè${NC} Tunnel SSH: ${GREEN}RUNNING${NC} (PID: $tunnel_pid, Port: $tunnel_port)"
    else
        echo -e "  ${RED}‚óè${NC} Tunnel SSH: ${RED}STOPPED${NC}"
    fi
    
    if [ "$backend_state" = "running" ]; then
        echo -e "  ${GREEN}‚óè${NC} Backend: ${GREEN}RUNNING${NC} (PID: $backend_pid, Port: $backend_port)"
    else
        echo -e "  ${RED}‚óè${NC} Backend: ${RED}STOPPED${NC}"
    fi
    
    if [ "$frontend_state" = "running" ]; then
        echo -e "  ${GREEN}‚óè${NC} Frontend: ${GREEN}RUNNING${NC} (PID: $frontend_pid, Port: $frontend_port)"
    else
        echo -e "  ${RED}‚óè${NC} Frontend: ${RED}STOPPED${NC}"
    fi
}

# Tue les processus zombies
kill_zombies() {
    info "üßπ Nettoyage des processus zombies..."
    
    local killed=0
    
    # Tuer les processus Node orphelins
    for pid in $(pgrep -f "node.*payload\|tsx.*server\|next.*dev" 2>/dev/null); do
        local ppid=$(ps -o ppid= -p "$pid" 2>/dev/null | tr -d ' ')
        if [ "$ppid" == "1" ] || [ -z "$ppid" ]; then
            kill "$pid" 2>/dev/null && killed=$((killed + 1))
        fi
    done
    
    # Tuer les tunnels SSH orphelins
    for pid in $(pgrep -f "ssh.*-L.*:.*:.*" 2>/dev/null); do
        local ppid=$(ps -o ppid= -p "$pid" 2>/dev/null | tr -d ' ')
        if [ "$ppid" == "1" ] || [ -z "$ppid" ]; then
            kill "$pid" 2>/dev/null && killed=$((killed + 1))
        fi
    done
    
    if [ "$killed" -gt 0 ]; then
        success "$killed processus zombie tu√©"
    else
        info "Aucun processus zombie trouv√©"
    fi
}

# Affiche les logs d'un service
show_logs() {
    local service="$1"
    local tail_count="${2:-200}"
    local project_id="${3:-}"
    
    if [ -z "$project_id" ]; then
        project_id=$(detect_project)
    fi
    
    local config=$(load_project_config "$project_id")
    if [ -z "$config" ]; then
        error "Projet '$project_id' introuvable dans la configuration"
    fi
    
    local pid=""
    case "$service" in
        tunnel)
            warning "Les logs du tunnel SSH ne sont pas disponibles"
            ;;
        back|backend)
            local log_file="$GMDEV_LOG_DIR/${project_id}.backend.log"
            [ -f "$log_file" ] && tail -n "$tail_count" "$log_file" || info "Aucun log backend: $log_file"
            ;;
        front|frontend)
            local log_file="$GMDEV_LOG_DIR/${project_id}.frontend.log"
            [ -f "$log_file" ] && tail -n "$tail_count" "$log_file" || info "Aucun log frontend: $log_file"
            ;;
        *)
            error "Service inconnu: $service"
            ;;
    esac
}

# Fonction doctor pour diagnostic
doctor() {
    local project_id="${1:-}"
    if [ -z "$project_id" ]; then
        project_id="$(detect_project)"
    fi

    local config
    config="$(load_project_config "$project_id" 2>/dev/null || true)"
    if [ -z "$config" ] || [ "$config" = "null" ]; then
        error "Projet '$project_id' introuvable dans $PROJECTS_CONFIG"
    fi

    local name backend_path frontend_path backend_port frontend_port tunnel_host local_mongo
    name="$(printf '%s' "$config" | jq -r '.name // "?"')"
    backend_path="$(printf '%s' "$config" | jq -r '.backendPath // ""')"
    frontend_path="$(printf '%s' "$config" | jq -r '.frontendPath // ""')"
    backend_port="$(printf '%s' "$config" | jq -r '.ports.backend // 3010')"
    frontend_port="$(printf '%s' "$config" | jq -r '.ports.frontend // 3000')"
    tunnel_host="$(printf '%s' "$config" | jq -r '.tunnel.host // ""')"
    local_mongo="$(printf '%s' "$config" | jq -r '.tunnel.localMongo // 27017')"

    printf '\n%s\n' "ü©∫ gmdev doctor ‚Äî $name ($project_id)"
    printf '%s\n' "Config: $PROJECTS_CONFIG"
    printf '%s\n' "State : $GMDEV_STATE_DIR"
    printf '\n'

    # D√©pendances
    local ok=1
    for bin in jq lsof; do
        if command -v "$bin" >/dev/null 2>&1; then
            printf '%s\n' "‚úÖ dep: $bin"
        else
            printf '%s\n' "‚ùå dep: $bin (manquant)"
            ok=0
        fi
    done

    # R√©pertoires
    if [ -n "$backend_path" ]; then
        if [ -d "$backend_path" ]; then
            printf '%s\n' "‚úÖ backendPath: $backend_path"
        else
            printf '%s\n' "‚ùå backendPath: $backend_path (introuvable)"
            ok=0
        fi
    else
        printf '%s\n' "‚ÑπÔ∏è backendPath: (absent) ‚Üí projet sans backend"
    fi

    if [ -n "$frontend_path" ]; then
        if [ -d "$frontend_path" ]; then
            printf '%s\n' "‚úÖ frontendPath: $frontend_path"
        else
            printf '%s\n' "‚ùå frontendPath: $frontend_path (introuvable)"
            ok=0
        fi
    else
        printf '%s\n' "‚ÑπÔ∏è frontendPath: (absent)"
    fi

    # Ports
    if lsof -ti:"$frontend_port" >/dev/null 2>&1; then
        printf '%s\n' "‚úÖ port frontend :$frontend_port (occup√© = OK si front tourne)"
    else
        printf '%s\n' "‚ÑπÔ∏è port frontend :$frontend_port (libre)"
    fi

    if [ -n "$backend_path" ]; then
        if lsof -ti:"$backend_port" >/dev/null 2>&1; then
            printf '%s\n' "‚úÖ port backend  :$backend_port (occup√© = OK si back tourne)"
        else
            printf '%s\n' "‚ÑπÔ∏è port backend  :$backend_port (libre)"
        fi
    fi

    # Tunnel
    if [ -n "$backend_path" ] && [ -n "$tunnel_host" ]; then
        if lsof -ti:"$local_mongo" >/dev/null 2>&1; then
            printf '%s\n' "‚úÖ tunnel port mongo :$local_mongo (occup√©)"
        else
            printf '%s\n' "‚ÑπÔ∏è tunnel port mongo :$local_mongo (libre)"
        fi
        # Test reachability (sans bloquer)
        if timeout 3 bash -lc "nc -z \"$tunnel_host\" 22" >/dev/null 2>&1; then
            printf '%s\n' "‚úÖ ssh: $tunnel_host:22 joignable"
        else
            printf '%s\n' "‚ö†Ô∏è ssh: $tunnel_host:22 non joignable (ou nc absent)"
        fi
    else
        printf '%s\n' "‚ÑπÔ∏è tunnel: non applicable (pas de backend ou pas de host)"
    fi

    printf '\n%s\n' "R√©sultat: $( [ "$ok" -eq 1 ] && printf '‚úÖ OK' || printf '‚ö†Ô∏è √Ä corriger' )"
    printf '\n'
}

# Active un projet (d√©sactive les autres)
activate_project() {
    local project_id="${1:-}"
    if [ -z "$project_id" ]; then
        project_id=$(detect_project)
    fi

    local config
    config=$(load_project_config "$project_id" 2>/dev/null || true)
    if [ -z "$config" ] || [ "$config" = "null" ]; then
        error "Projet '$project_id' introuvable dans $PROJECTS_CONFIG"
    fi

    info "üîÑ Activation du projet: $project_id"
    
    # Charger tous les projets et mettre √† jour
    local temp_file
    temp_file=$(mktemp)
    
    # D√©sactiver tous les projets et arr√™ter leurs services
    jq --arg target_id "$project_id" '
        .projects[] | 
        if .id == $target_id then
            .enabled = true
        else
            if (.enabled // true) == true then
                .enabled = false
            else
                .
            end
        end
    ' "$PROJECTS_CONFIG" > /dev/null 2>&1 || true
    
    # Mettre √† jour tous les projets
    jq --arg target_id "$project_id" '
        .projects = [
            .projects[] | 
            if .id == $target_id then
                .enabled = true
            else
                if (.enabled // true) == true then
                    .enabled = false
                else
                    .
                end
            end
        ]
    ' "$PROJECTS_CONFIG" > "$temp_file" 2>/dev/null
    
    if [ $? -eq 0 ]; then
        mv "$temp_file" "$PROJECTS_CONFIG"
        
        # Arr√™ter les services des autres projets qui √©taient actifs
        local all_projects
        all_projects=$(jq -c '.projects[]' "$PROJECTS_CONFIG" 2>/dev/null)
        echo "$all_projects" | while IFS= read -r p; do
            local p_id p_enabled
            p_id=$(echo "$p" | jq -r '.id')
            p_enabled=$(echo "$p" | jq -r '.enabled // true')
            
            if [ "$p_id" != "$project_id" ] && [ "$p_enabled" = "true" ]; then
                info "Arr√™t des services du projet '$p_id'..."
                local p_backend_path
                p_backend_path=$(echo "$p" | jq -r '.backendPath // ""')
                if [ -n "$p_backend_path" ] && [ "$p_backend_path" != "null" ] && [ "$p_backend_path" != "" ]; then
                    stop_backend "$p" 2>/dev/null || true
                    stop_tunnel "$p" 2>/dev/null || true
                fi
                stop_frontend "$p" 2>/dev/null || true
            fi
        done
        
        local project_name
        project_name=$(echo "$config" | jq -r '.name // "?"')
        success "Projet '$project_name' ($project_id) activ√©. Les autres projets ont √©t√© d√©sactiv√©s."
    else
        error "Impossible de mettre √† jour la configuration"
    fi
}

# Affiche l'aide
show_help() {
    cat << EOF
GestionMax Dev Runtime (gmdev) v2.0.0

Usage: gmdev <command> [options]

Commands:
  status                    Affiche le statut de tous les services
  start <service>           D√©marre un service (tunnel|back|front)
  stop <service>            Arr√™te un service (tunnel|back|front)
  restart <service>         Red√©marre un service (tunnel|back|front)
  up [project_id]           D√©marre tous les services applicables (tunnel ‚Üí backend ‚Üí frontend)
  down [project_id]         Arr√™te tous les services actifs
  activate [project_id]     Active un projet (d√©sactive les autres automatiquement)
  deactivate [project_id]   D√©sactive un projet et arr√™te ses services
  doctor                    Diagnostic syst√®me complet (d√©pendances, ports, PID, logs)
  logs <service> [--tail N] Affiche les logs d'un service
  kill-zombies              Tue les processus zombies

Examples:
  gmdev status              # Statut du projet courant
  gmdev start back          # D√©marre le backend
  gmdev stop front          # Arr√™te le frontend
  gmdev up                  # D√©marre tous les services applicables
  gmdev down                # Arr√™te tous les services
  gmdev activate            # Active le projet courant (d√©sactive les autres)
  gmdev activate my-project # Active un projet sp√©cifique
  gmdev deactivate          # D√©sactive le projet courant
  gmdev doctor              # Diagnostic syst√®me complet
  gmdev logs back --tail 100
  gmdev kill-zombies

Configuration:
  Fichier: \$HOME/.gestionmax-devcenter/projects-v3.json
  Logs: \$XDG_STATE_HOME/gmdev/logs
  PID: \$XDG_STATE_HOME/gmdev/pids
EOF
}

# D√©sactive un projet
deactivate_project() {
    local project_id="${1:-}"
    if [ -z "$project_id" ]; then
        project_id=$(detect_project)
    fi

    local config
    config=$(load_project_config "$project_id" 2>/dev/null || true)
    if [ -z "$config" ] || [ "$config" = "null" ]; then
        error "Projet '$project_id' introuvable dans $PROJECTS_CONFIG"
    fi

    info "üîÑ D√©sactivation du projet: $project_id"
    
    # Mettre √† jour le projet
    local temp_file
    temp_file=$(mktemp)
    jq --arg id "$project_id" '(.projects[] | select(.id == $id) | .enabled) = false' "$PROJECTS_CONFIG" > "$temp_file" 2>/dev/null
    
    if [ $? -eq 0 ]; then
        mv "$temp_file" "$PROJECTS_CONFIG"
        
        # Arr√™ter tous les services de ce projet
        local backend_path
        backend_path=$(echo "$config" | jq -r '.backendPath // ""')
        if [ -n "$backend_path" ] && [ "$backend_path" != "null" ] && [ "$backend_path" != "" ]; then
            stop_backend "$config" 2>/dev/null || true
            stop_tunnel "$config" 2>/dev/null || true
        fi
        stop_frontend "$config" 2>/dev/null || true
        
        local project_name
        project_name=$(echo "$config" | jq -r '.name // "?"')
        success "Projet '$project_name' ($project_id) d√©sactiv√© et ses services arr√™t√©s."
    else
        error "Impossible de mettre √† jour la configuration"
    fi
}

# Point d'entr√©e principal
main() {
    local command="${1:-help}"
    
    case "$command" in
        status)
            # V√©rifier si --json ou --format json est demand√©
            if [ "${2:-}" = "--json" ]; then
                # gmdev status --json [project_id]
                show_status "${3:-}" "--json"
            elif [ "${2:-}" = "--format" ] && [ "${3:-}" = "json" ]; then
                # gmdev status --format json [project_id]
                show_status "${4:-}" "--format" "json"
            else
                # gmdev status [project_id]
                show_status "${2:-}"
            fi
            ;;
        start)
            if [ -z "${2:-}" ]; then
                error "Service requis. Usage: gmdev start <tunnel|back|front>"
            fi
            start_service "$2" "${3:-}"
            ;;
        stop)
            if [ -z "${2:-}" ]; then
                error "Service requis. Usage: gmdev stop <tunnel|back|front>"
            fi
            stop_service "$2" "${3:-}"
            ;;
        restart)
            if [ -z "${2:-}" ]; then
                error "Service requis. Usage: gmdev restart <tunnel|back|front>"
            fi
            restart_service "$2" "${3:-}"
            ;;
        logs)
            if [ -z "${2:-}" ]; then
                error "Service requis. Usage: gmdev logs <tunnel|back|front> [--tail N]"
            fi
            local tail_count=200
            if [ "${3:-}" == "--tail" ] && [ -n "${4:-}" ]; then
                tail_count="${4}"
            fi
            show_logs "$2" "$tail_count" "${5:-}"
            ;;
        kill-zombies)
            kill_zombies
            ;;
        up)
            # D√©marrer tous les services applicables (tunnel ‚Üí backend ‚Üí frontend)
            local project_id="${2:-$(detect_project)}"
            local config
            config=$(load_project_config "$project_id")
            
            info "üöÄ D√©marrage de tous les services applicables pour le projet: $project_id"
            
            # Tunnel uniquement si backend existe et tunnel activ√©
            local backend_path
            backend_path=$(echo "$config" | jq -r '.backendPath // ""')
            local tunnel_enabled
            tunnel_enabled=$(echo "$config" | jq -r '.tunnel.enabled // false')
            
            if [ -n "$backend_path" ] && [ "$backend_path" != "null" ] && [ "$backend_path" != "" ] && [ "$tunnel_enabled" = "true" ]; then
                info "üì° D√©marrage du tunnel..."
                start_tunnel "$config" || warning "√âchec du d√©marrage du tunnel - continuation..."
                sleep 1
            fi
            
            # Mini-gods (service SSH) si configur√©
            local mini_gods_command
            mini_gods_command=$(echo "$config" | jq -r '.commands["mini-gods"] // empty')
            if [ -n "$mini_gods_command" ] && [ "$mini_gods_command" != "null" ] && [ "$mini_gods_command" != "" ]; then
                info "üéÆ D√©marrage de mini-gods..."
                start_ssh_service "$config" "mini-gods" || warning "√âchec du d√©marrage de mini-gods - continuation..."
                sleep 1
            fi
            
            # Backend uniquement si backendPath existe
            if [ -n "$backend_path" ] && [ "$backend_path" != "null" ] && [ "$backend_path" != "" ]; then
                info "üîß D√©marrage du backend..."
                start_backend "$config" || warning "√âchec du d√©marrage du backend - continuation..."
                sleep 1
            fi
            
            # Frontend toujours (si frontendPath existe)
            local frontend_path
            frontend_path=$(echo "$config" | jq -r '.frontendPath // ""')
            if [ -n "$frontend_path" ] && [ "$frontend_path" != "null" ] && [ "$frontend_path" != "" ]; then
                info "üé® D√©marrage du frontend..."
                start_frontend "$config" || warning "√âchec du d√©marrage du frontend"
            fi
            
            success "‚úÖ Tous les services applicables ont √©t√© d√©marr√©s"
            ;;
        down)
            # Arr√™ter tous les services actifs
            local project_id="${2:-$(detect_project)}"
            local config
            config=$(load_project_config "$project_id")
            
            info "üõë Arr√™t de tous les services pour le projet: $project_id"
            
            # Arr√™ter dans l'ordre inverse : frontend ‚Üí backend ‚Üí tunnel
            local frontend_path
            frontend_path=$(echo "$config" | jq -r '.frontendPath // ""')
            if [ -n "$frontend_path" ] && [ "$frontend_path" != "null" ] && [ "$frontend_path" != "" ]; then
                info "üé® Arr√™t du frontend..."
                stop_frontend "$config" || warning "Frontend non d√©marr√© ou d√©j√† arr√™t√©"
            fi
            
            local backend_path
            backend_path=$(echo "$config" | jq -r '.backendPath // ""')
            if [ -n "$backend_path" ] && [ "$backend_path" != "null" ] && [ "$backend_path" != "" ]; then
                info "üîß Arr√™t du backend..."
                stop_backend "$config" || warning "Backend non d√©marr√© ou d√©j√† arr√™t√©"
            fi
            
            local tunnel_enabled
            tunnel_enabled=$(echo "$config" | jq -r '.tunnel.enabled // false')
            if [ "$tunnel_enabled" = "true" ]; then
                info "üì° Arr√™t du tunnel..."
                stop_tunnel "$config" || warning "Tunnel non d√©marr√© ou d√©j√† arr√™t√©"
            fi
            
            success "‚úÖ Tous les services ont √©t√© arr√™t√©s"
            ;;
        doctor)
            doctor "${2:-}"
            ;;
        activate)
            activate_project "${2:-}"
            ;;
        deactivate)
            deactivate_project "${2:-}"
            ;;
        --version|-v)
            echo "gmdev v2.0.0"
            ;;
        help|--help|-h|"")
            show_help
            ;;
        *)
            error "Commande inconnue: $command. Utilisez 'gmdev help' pour l'aide."
            ;;
    esac
}

# V√©rifier les d√©pendances
if ! command -v jq &> /dev/null; then
    error "jq est requis mais n'est pas install√©. Installez-le avec: sudo apt install jq"
fi

if ! command -v lsof &> /dev/null; then
    error "lsof est requis mais n'est pas install√©. Installez-le avec: sudo apt install lsof"
fi

# Ex√©cuter la commande
main "$@"

